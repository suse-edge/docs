[#components-nmc]
= Edge Networking

ifdef::env-github[]
:imagesdir: ../images/
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

In this section we’re going to describe the approach SUSE Edge undertakes to customize the various different networking options on your edge nodes.
Modern Linux distributions (incl. SLE Micro) are leveraging NetworkManager to suit their configuration needs.

At the time of this writing, SUSE Edge Networking is not a standalone product. This guide will, however, dive deep into
what it consists of, how it is integrated into the SUSE Edge solution and how it can be used outside of it.

== NetworkManager overview

NetworkManager is a program that manages the primary network connection and other connection interfaces.
It is handled by systemd and is shipped with all necessary service unit files.

NetworkManager stores all network configurations as connections, which are a collection of data that describes how to create or connect to a network.
These connections are stored as files in the `/etc/NetworkManager/system-connections/` directory.

Details about NetworkManager can be found in the https://documentation.suse.com/sle-micro/5.5/html/SLE-Micro-all/cha-nm-configuration.html[upstream SLE Micro documentation].

== nmstate overview

There are different solutions attempting to automate and manage host networking and one of the most popular ones is nmstate.
It is a library (with an accompanying CLI tool) which offers a declarative API for network configurations via a predefined schema.

Details about nmstate can be found in the https://nmstate.io/[upstream documentation].

== Enter: NetworkManager Configurator (nmc)

Edge Networking is achieved via a CLI tool called NetworkManager Configurator or _nmc_ in short.
It is leveraging the functionality provided by the nmstate library and as such it is fully capable of
configuring static IP addresses, DNS servers, VLANs, bonding, bridges, etc.
This tool allows us to generate network configurations from predefined desired states and to apply those across many different nodes in an automated fashion.

Details about the NetworkManager Configurator (nmc) can be found in the https://github.com/suse-edge/nm-configurator[upstream repository].

== How does SUSE Edge use NetworkManager Configurator?

SUSE Edge utilizes _nmc_ for the network customizations in the various different provisioning models:

* Custom network configurations in the Direct Network Provisioning scenarios (<<quickstart-metal3>>)
* Declarative static configurations in the Image Based Provisioning scenarios (<<quickstart-eib>>)

== Configuring with Edge Image Builder

Edge Image Builder is a staple when it comes to configuring multiple hosts with a single OS image.
In this section we'll show how you can use a declarative approach to describe the desired network states,
how those are converted to the respective NetworkManager connections and are then applied during the provisioning process.

=== Prerequisites

If you're following this guide, it's assumed that you've got the following already available:

* An x86_64 physical host (or virtual machine) running SLES 15 SP5 or openSUSE Leap 15.5,
and with virtualization extensions enabled in the BIOS
(see https://documentation.suse.com/sles/15-SP5/html/SLES-all/cha-virt-support.html#sec-kvm-requires-hardware[here] for details).
* A pre-installed container runtime (e.g. Podman)
* A copy of the SLE Micro 5.5 RAW image found https://www.suse.com/download/sle-micro/[here]

=== Creating the image configuration directory

Let's start with creating the configuration directory:

[,shell]
----
export CONFIG_DIR=$HOME/eib
mkdir -p $CONFIG_DIR/base-images
----

We will now ensure that the downloaded base image copy is moved over to the configuration directory:

[,shell]
----
mv /path/to/downloads/SLE-Micro.x86_64-5.5.0-Default-GM.raw $EIB/base-images/
----

> NOTE: EIB is never going to modify the base image input.

The configuration directory at this point should look like the following:

[,console]
----
└── base-images/
    └── SLE-Micro.x86_64-5.5.0-Default-GM.raw
----

=== Creating the image definition file

The definition file describes the majority of configurable options that the Edge Image Builder supports.

Let's start with a very basic definition file for our OS image:

[,shell]
----
cat << EOF > $EIB/definition.yaml
apiVersion: 1.0
image:
  arch: x86_64
  imageType: raw
  baseImage: SLE-Micro.x86_64-5.5.0-Default-GM.raw
  outputImageName: modified-image.raw
operatingSystem:
  users:
    - username: root
      encryptedPassword: $6$jHugJNNd3HElGsUZ$eodjVe4te5ps44SVcWshdfWizrP.xAyd71CVEXazBJ/.v799/WRCBXxfYmunlBO2yp1hm/zb4r8EmnrrNCF.P/
EOF
----

The `image` section is required, and it specifies the input image, its architecture and type, as well as what the output image will be called.
The `operatingSystem` section, albeit not necessary, will help us to log in on the provisioned systems with the `root:eib` credentials pair.

The configuration directory at this point should look like the following:
[,console]
----
├── definition.yaml
└── base-images/
    └── SLE-Micro.x86_64-5.5.0-Default-GM.raw
----

=== Defining the network configurations

The desired network configurations are not part of the image definition file that we just created.
We'll now populate those under the special `network/` directory. Let's create it:

[,shell]
----
mkdir -p $CONFIG_DIR/network
----

As previously mentioned, the NetworkManager Configurator (_nmc_) tool expects an input in the form of pre-defined schema.
You can find how to set up a wide variety of different networking options in the https://nmstate.io/examples.html[upstream NMState examples documentation].

This guide will explain how to configure the networking on three different nodes:

* A node which uses two Ethernet interfaces
* A node which uses network bonding
* A node which uses a network bridge

> NOTE: The following assumes a default `libvirt` network with an IP address range `192.168.122.1/24`. Adjust accordingly if this differs in your environment.

Let's create the desired states for the first node which we will call `node1.suse.com`:

[,shell]
----
cat << EOF > $EIB/network/node1.suse.com.yaml
routes:
  config:
    - destination: 0.0.0.0/0
      metric: 100
      next-hop-address: 192.168.122.1
      next-hop-interface: eth0
      table-id: 254
    - destination: 192.168.122.0/24
      metric: 100
      next-hop-address:
      next-hop-interface: eth0
      table-id: 254
dns-resolver:
  config:
    server:
      - 192.168.122.1
      - 8.8.8.8
interfaces:
  - name: eth0
    type: ethernet
    state: up
    mac-address: 34:8A:B1:4B:16:E1
    ipv4:
      address:
        - ip: 192.168.122.50
          prefix-length: 24
      dhcp: false
      enabled: true
    ipv6:
      enabled: false
  - name: eth3
    type: ethernet
    state: down
    mac-address: 34:8A:B1:4B:16:E2
    ipv4:
      address:
        - ip: 192.168.122.55
          prefix-length: 24
      dhcp: false
      enabled: true
    ipv6:
      enabled: false
EOF
----

In this example we define a desired state of two Ethernet interfaces (eth0 and eth3),
their requested IP addresses, routing and DNS resolution.

[WARNING]
====
You must ensure that the MAC addresses of all Ethernet interfaces are listed.
Those are used during the provisioning process to determine which configurations are relevant for the particular node.
====

Next up is the second node which we will call `node2.suse.com` and which will use network bonding:

[,shell]
----
cat << EOF > $EIB/network/node2.suse.com.yaml
routes:
  config:
    - destination: 0.0.0.0/0
      metric: 100
      next-hop-address: 192.168.122.1
      next-hop-interface: bond99
      table-id: 254
    - destination: 192.168.122.0/24
      metric: 100
      next-hop-address:
      next-hop-interface: bond99
      table-id: 254
dns-resolver:
  config:
    server:
      - 192.168.122.1
      - 8.8.8.8
interfaces:
  - name: bond99
    type: bond
    state: up
    ipv4:
      address:
        - ip: 192.168.122.60
          prefix-length: 24
      enabled: true
    link-aggregation:
      mode: balance-rr
      options:
        miimon: '140'
      port:
        - eth0
        - eth1
  - name: eth0
    type: ethernet
    state: up
    mac-address: 34:8A:B1:4B:16:E3
    ipv4:
      enabled: false
    ipv6:
      enabled: false
  - name: eth1
    type: ethernet
    state: up
    mac-address: 34:8A:B1:4B:16:E4
    ipv4:
      enabled: false
    ipv6:
      enabled: false
EOF
----

In this example we define a desired state of two Ethernet interfaces (eth0 and eth1) which are not enabling IP addressing,
however, a bond with a round-robin policy is and its respective address is used to forward the networking traffic.

Lastly, we'll create the third and final desired state file which will be utilizing a network bridge and which we'll call `node3.suse.com`:

[,shell]
----
cat << EOF > $EIB/network/node3.suse.com.yaml
routes:
  config:
    - destination: 0.0.0.0/0
      metric: 100
      next-hop-address: 192.168.122.1
      next-hop-interface: linux-br0
      table-id: 254
    - destination: 192.168.122.0/24
      metric: 100
      next-hop-address:
      next-hop-interface: linux-br0
      table-id: 254
dns-resolver:
  config:
    server:
      - 192.168.122.1
      - 8.8.8.8
interfaces:
  - name: eth0
    type: ethernet
    state: up
    mac-address: 34:8A:B1:4B:16:E5
    ipv4:
      enabled: false
    ipv6:
      enabled: false
  - name: linux-br0
    type: linux-bridge
    state: up
    ipv4:
      address:
        - ip: 192.168.122.70
          prefix-length: 24
      dhcp: false
      enabled: true
    bridge:
      options:
        group-forward-mask: 0
        mac-ageing-time: 300
        multicast-snooping: true
        stp:
          enabled: true
          forward-delay: 15
          hello-time: 2
          max-age: 20
          priority: 32768
      port:
        - name: eth0
          stp-hairpin-mode: false
          stp-path-cost: 100
          stp-priority: 32
EOF
----

This last example defines an Ethernet interface and a bridge over it with some default options.

The configuration directory at this point should look like the following:
[,console]
----
├── definition.yaml
├── network/
│   │── node1.suse.com.yaml
│   │── node2.suse.com.yaml
│   └── node3.suse.com.yaml
└── base-images/
    └── SLE-Micro.x86_64-5.5.0-Default-GM.raw
----

> NOTE: The name of the files under the `network/` directory is intentional.
It corresponds to the hostname which will be set during the provisioning process.
